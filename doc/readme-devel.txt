next
----
x linear.py
  if line is ready,
    - roads
    - railways
    - bridges are rather simple
  - place lots along lines
  - infrastructure for quarters? Residential, commercial, industrial, harbor, train station

night lighting
--------------
London: vimeo.com/66807202
more diverse. White, red yellow dot lights
streets only light orange
some blue remains in facades -- but thats maybe not completely at night?
facades high up white light


- postgis? get osm2pgsql
x get roofs back
- put roofs in same object, re-use nodes/separate object
x get textures back
x relations with 2+ inner rings
- merge adjacent buildings
- texture gable walls
x usability: try .pkl first, failing that, try .osm. Warn about existing .pkl before .osm parsing.
x compute angles for ground nodes, simplify large angles
x pitched roofs on relations
- discard small inner ways

- roads
- bridges
- regions: commercial, urban, suburban, industrial, park, airports
- simple house: shared model. Complex house: facade
- ground patch (garden)
- street lights
- traffic signs

Use postGIS?
+ learn SQL, database stuff
- takes time. Refactoring!
+ outsource queries, much more complex queries possible.
  - what queries do we really need?
- should this once go into FG -- don't want dependency there!


textures
--------
Since you could have a number of cities generated by osm2city which would share textures, currently all textures reside in the folder /some/place/tex/. An actual scenery folder, say, Objects/w130n30/w123n37/ will have a link to /some/place/tex. The .ac objects inside Objects/w130n30/w123n37/ will then e.g. load a texture tex/facade.png

I think the tex/ folder is included in the LOWI download.

Currently we use facade textures and roof textures. Since some facade textures might not match with some roof textures, we use a mechanism of provides=[] and requires=[] features: A texture could require a black roof, while providing a modern, commercial facade.

You can create own facade textures. They're registered in textures.py:

        facades.append(Texture('tex/DSCF9495_pow2',
                                14, [585, 873, 1179, 1480, 2048], True,
                                19.4, [274, 676, 1114, 1542, 2048], False, True,
                                requires=['roof:colour:black'],
                                provides=['shape:residential','age:old','compat:roof-flat','compat:roof-gable']))

This registeres a file tex/DSCF9495_pow2. The extention .png is added automatically when writing the .ac file, so make sure you use only .png textures.

The second line in the above example says the texture
- is 14m wide
- can be split at u = 585, 873, ... 2048 px, where u is the horizontal coordinate. The last value 2048 of this list also gives the width in px. Note that the .ac file uses nondimensionalized coordinates (0 ... 1). Internally, all coordinates are divided by the last value. Therefore, when preparing the textures, you can work with the highest resolution possible and register those numbers, then downscale the texture for actual flightgear use. Once the next generation of graphics cards arrives you just replace the textures with higher resolution ones.
- the texture can repeat in horizontal direction

The third line gives the same information for the vertical direction:
- 19.4m height
- can split at 274, 676, ... 2048px,
- the texture cannot repeat in vertical direction
- the texture has a roof section (I've forgotten what this actually means, will have to check...)

The fourth and fifth line state compatibility with other textures: This facade texture requires a black roof. It provides an old-aged, residential facade, and is compatible with both flat and gable roofs.


Assigning specific textures
---------------------------
Currently, the textures are assigned somewhat randomly to the buildings. Support for specific textures is not implemented yet. But with some python knowledge, you could code that yourself.

To use specific textures for specific types of buildings, you would have to read the building type from the OSM file. OSM parsing is done in the ways method (osm2city.py, line 145) of the class wayExtract(object). Check lines 160-165, you would probably need something similar to process your type tag. Then in line 176, a building object is created
  building = Building(osm_id, tags, _refs, _name, _height, _levels)
You would pass your type tag to the building class here, and of course extend the Building class (starting at line 102) to store that tag.

Finally, in building_lib.py, around line 425:
        b.facade_texture = facades.find_matching(requires, b.height)
This decides which facade texture is used for a building. b is an instance of the class Building. You could pass here the b.type tag, then extend the find_matching method to find a texture matching that tag.



getting (huge) data from OSM
----------------------
http://wiki.openstreetmap.org/wiki/Overpass_API/XAPI_Compatibility_Layer

XAPI URL Builder: A GUI for BBox
http://harrywood.co.uk/maps/uixapi/xapi.html
builds something like
www.overpass-api.de/api/xapi?map?bbox=13.63,50.96,13.88,51.17
EDDC www.overpass-api.de/api/xapi?*[building=*][bbox=13.63,50.96,13.88,51.17]
LOWI www.overpass-api.de/api/xapi?*[building=*][bbox=11.16898,47.20837,11.79108,47.38161]


hard-coded stuff that should go into input file
-----------------------------------------------
lon/lat for area
OSM data file name
total_objects
pkl file name
elevation data file name
outfile prefix
tile size
default_height
Limits:
  random_level_height min/max
  random_levels min/max
  random_levels_skyscraper min/max, gaussian distribution?
  min building area
  min height
  LOD classes/percentages/area limits
  min height/levels for position light
  min object count/tile
  simplify threshold (min building edge length)
  min area for a given number of floors
  percentage of small buildings skipped
  max area for pitched roofs
  min dist to static buildings
roof creation paramters


Tile size vs. frame rate
------------------------
with LOD
tile
size	fps
200	13
500	15
1000	15
2000	15

w/o LOD
6 fps

no roofs at all: 17-18fps


Any significant gains with one texture only? Or skipping pitched roofs (putting them in separate LOD later)?
==> one texture only +1 fps
==> no pitched roofs +4 fps

benchmark LOWI
--------------

airport="LOWI --offset-azimuth=260 --heading=265 --offset-distance=4.0 --in-air --altitude=3000"
aircraft=ufo

base
  13-14 fps

total buildings 50000
written         34514
skipped
  small         15334
  nearby        136
  texture       0
vertices        546782
surfaces        307415
LOD bare        10612 (31)
LOD rough       23902 (69)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2   1353
    50 m^2   2994
   100 m^2   8032
   200 m^2  17667
   500 m^2   2726
  1000 m^2    831
  2000 m^2    342
  5000 m^2     61
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.
---
with
  b.roof_flat = True
  b.roof_separate = False
  17-18 fps

total buildings 50000
written         34410
skipped
  small         15440
  nearby        135
  texture       0
vertices        463682
surfaces        265768
LOD bare        10670 (31)
LOD rough       23740 (69)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2   1382
    50 m^2   2891
   100 m^2   7991
   200 m^2  17679
   500 m^2   2731
  1000 m^2    831
  2000 m^2    342
  5000 m^2     62
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.
--
b.roof_flat = True
b.roof_separate = False
one texture only
18-19fps

total buildings 50000
written         34564
skipped
  small         15282
  nearby        137
  texture       0
vertices        466414
surfaces        267317
LOD bare        10588 (31)
LOD rough       23976 (69)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2   1361
    50 m^2   2964
   100 m^2   8122
   200 m^2  17686
   500 m^2   2724
  1000 m^2    832
  2000 m^2    342
  5000 m^2     61
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.
---
pitched roofs allowed (untextured), but one texture only
14 fps

total buildings 50000
written         34514
skipped
  small         15334
  nearby        135
  texture       0
vertices        546968
surfaces        307515
LOD bare        10653 (31)
LOD rough       23861 (69)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2   1380
    50 m^2   2891
   100 m^2   8097
   200 m^2  17680
   500 m^2   2732
  1000 m^2    828
  2000 m^2    343
  5000 m^2     62
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0


simplify or not
---------------
LOWI benchmark
LOD 3000 7000 20000
threshold 0.00000000001
11-12fps

total buildings 50000
written         33053
skipped
  small         16817
  nearby        116
  texture       0
pitched roof    12593
ground nodes    316079
  simplified    50
vertices        527480
surfaces        296351
LOD bare        10660 (32)
LOD rough       22393 (68)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2      0
    50 m^2   2851
   100 m^2   8108
   200 m^2  17677
   500 m^2   2726
  1000 m^2    827
  2000 m^2    342
  5000 m^2     62
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.

--
threshold 0.1
11-12fps

total buildings 50000
written         32992
skipped
  small         16881
  nearby        111
  texture       0
pitched roof    14957
ground nodes    303204
  simplified    12925
vertices        521838
surfaces        293440
LOD bare        10647 (32)
LOD rough       22345 (68)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2      0
    50 m^2   2854
   100 m^2   8044
   200 m^2  17642
   500 m^2   2728
  1000 m^2    831
  2000 m^2    342
  5000 m^2     62
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.

--
threshold 0.5
11-12fps

total buildings 50000
written         33134
skipped
  small         16737
  nearby        114
  texture       0
pitched roof    15510
ground nodes    296201
  simplified    19928
vertices        515658
surfaces        290488
LOD bare        10600 (32)
LOD rough       22534 (68)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2      0
    50 m^2   2925
   100 m^2   8106
   200 m^2  17655
   500 m^2   2720
  1000 m^2    832
  2000 m^2    342
  5000 m^2     61
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.

---
threshold 1.0
11-12fps

total buildings 50000
written         33201
skipped
  small         16667
  nearby        118
  texture       0
pitched roof    16733
ground nodes    276576
  simplified    39553
vertices        493500
surfaces        279489
LOD bare        10757 (32)
LOD rough       22444 (68)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2      0
    50 m^2   2965
   100 m^2   8163
   200 m^2  17629
   500 m^2   2729
  1000 m^2    829
  2000 m^2    344
  5000 m^2     62
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.
---
threshold 2.0
10-11fps (??)
total buildings 50000
written         32854
skipped
  small         17023
  nearby        107
  texture       0
pitched roof    20142
ground nodes    242729
  simplified    73400
vertices        455698
surfaces        260227
LOD bare        10460 (32)
LOD rough       22394 (68)
LOD detail      0 ( 0)
above
     1 m^2      0
    10 m^2      0
    20 m^2      0
    50 m^2   2983
   100 m^2   7983
   200 m^2  17448
   500 m^2   2714
  1000 m^2    828
  2000 m^2    342
  5000 m^2     62
 10000 m^2     15
 20000 m^2      3
 50000 m^2      0
done.
---


single_object_per_tile
======================
myfg dev  24, or 16-17 facing towards LOWI
drawables 1057   2300

previously 16 or 12

now:

total buildings 56580
parse errors    0
written         16315
skipped
small         40244
nearby        0
no elevation  21
no texture    0
pitched roof    0
complex       0
roof_errors   0
ground nodes    311010
simplified    46948
vertices        0
surfaces        0
LOD bare        1 ( 0 %)
LOD rough       6640 (41 %)
LOD detail      9674 ( 0 %)

prev:

total buildings 56580
parse errors    0
written         16120
skipped
small         40439
nearby        0
no elevation  21
no texture    0
pitched roof    0
complex       0
roof_errors   0
ground nodes    311010
simplified    46948
vertices        211438
surfaces        108416
LOD bare        1 ( 0 %)
LOD rough       6634 (41 %)
LOD detail      9485 ( 0 %)
above
1 m^2      1 |
10 m^2      0 |
20 m^2      0 |
50 m^2      1 |
100 m^2   3808 |###########################
200 m^2   7795 |########################################################
500 m^2   3030 |#####################
1000 m^2    916 |######
2000 m^2    376 |##
5000 m^2     68 |
10000 m^2     16 |
20000 m^2      3 |
50000 m^2      0 |

repeat textures?
----------------
+ more simple coding
+ no additional verts
- future use. What if global texture atlas becomes standard?
  -> by then, osm2city will be integrated into FG
20 % of buildings make use of repeatx

ground texture
--------------
1. use a patch of ground for every building.
+ easy to code first try
+ better resolution
- eventually needs meshing

2. one large texture, paint on it
- must code paint algs -- is that useful in future?
+ less verts, but needs huge texture

long term
---------
city    lot     # lots
50k     20m     6M
20k             1M
10k             250k


- need OSM roads in FG
1. use all OSM buildings
   + best alignment with roads
   + best match with RL
   - need additional data
   - less detailed buildings, unless details added procedurally

2. place shared models along OSM roads
   + can still use large OSM buildings (put into shared model DB?)
   + can use detailed, hand-modeled buildings
   + best match with ground texture
   - need a number of hand-modeled buildings

- pre-processor
  - get OSM roads, at least primary + secondary
  - either use also residential roads or generate them procedurally
  - generate lots, with size being a function of population density? Land use?
  - place suitable shared model

  problems:
  - large city -> huge vertex count. Need ground LOD?
  - levels:
    3. all buildings, all lots, all roads
    2. some buildings, quarters bounded by secondary roads
    1. only very large buildings, generic texture within landclass boundaries
      -> switching from 1 to 2 obvious unless far out


General approaches
------------------
- texture + mask + random buildings
  + completely generic, no data required other than land use
  - generic texture will never perfectly match RL roads

 unless texture per lot

ground texture in shared model:
------------------------------
require all nodes of face at z=0
walls can still/should extend below 0
road access point at 0,0,0 centered?
- prevents using all existing shared models
-> add meta-info
- can get extends from shared model automatically

The state of cities in FG & how to move forward
-----------------------------------------------

osm2city now merges all buildings into a few objects per 2x2km (used to be some 1000s), reducing the number of drawables tremendously. The result renders indeed much faster: link. I can have 60k buildings in a scene and still get reasonable frame rate on my mid-range system. Thanks again to those of you who convinced me at FSweekend 2013!

Now I wonder how to move forward. As I said previously, my long-term goal is a better representation of cities in FG. My feature wish-list is this:

1) use real primary/secondary road data. If residential roads are available, use even that, otherwise create those procedurally (within city landclass boundaries).
Then, buildings should
2) be aligned with roads
3) match the ground texture
4) allow for more detail than just a textured quad plus roof. That is, allow using a set of (10, 20, 100) hand-modeled buildings, possibly with LOD.
5) not collide with static models
6) vegetation should not interfere with anything above -- no trees on roads or houses.

The current urban texture, Stuart's random buildings and using placement masks fulfil 2, 3 and 6, probably also 5. Extending this to allow 4 might also be possible. But I don't see how this could play nicely with 1. Ideas?

I'm proposing this, which I think is pretty much what x-plane does:

- use a very unobtrusive (greenish/grayish) generic ground texture
- use a real, detailed road network (vector data)
- generate lots along the roads
- place hand-modeled buildings on these lots. These buildings would come with a patch of specific ground texture, let's call it a 'garden'.

I could rather easily fulfil 1-5 by extending osm2city to do that outside of FG, eventually creating low-object-count/low-texture-count 2x2km tiles ready for use with FG. Roads would be created as textured bands sitting slighty above the terrain. Could generate bridges. Use LOD. Osm2city has prototypes for most of this already (except for a shared model loader/merging a number of shared models into one object -- which I think is not that difficult to code in python)

However, this approach still collides with 6.

Question: what would be the best way to achive 1-6? Either within FG, or with external tools? I'm now sufficiently convinced 1-6 is possible performance-wise, and I'm ready to dive in the C++ side of things. I have no experience with GLSL though, but I'm willing to learn.

I know TG can create a dense network of textured roads, and work towards scenery LOD is underway, which might eventually give us residential roads. However, to align buildings with roads, we'd still need their (OSM) line data in FG.

I'm also confident I could write code that loads N shared models, copies them a couple of thousand times, and places them into the scene as one big object. That of course eats memory. No idea if a shader could achive this more efficiently?

And what about the garden? A textured rectangle, slighty floating above the ground? Would that cause severe z-fighting? Is there a better way with shaders? Or create the urban landclass completely automatic at scenery load time?

ThomasA
---
Textured roofs now look better for small buildings. However, there is only one texture so far. Also, large , which also looks silly for large area buildings, you'd still get artifacts.
---
Let me try to reply to some of these:

    > I'm also confident I could write FG/SG/OSG code that loads N shared
    > models, copies them a couple of thousand times, and places them into the
    > scene as one big object. That of course eats memory. No idea if a shader
    > could achieve this more efficiently?
    >
    > And what about the garden? A textured rectangle, slighty floating above
    > the ground? Would that cause severe z-fighting? Is there a better way
    > with shaders? Or create the urban land class consisting of those little
    > lots completely automatic at scenery load time?

    My main concern would be to implement this in an optional way. We are seeing a fair fraction of users with low-end systems having problems even running the 2.0 scenery. If they're getting additional 60k buildings shipped in a precomputed way (which would be the case if they end up as static models), cities become no-fly zones for these users. I know that Paris already is for some.

    Stuart has dropped the merging models approach for random buildings in favour of an instancing approach because large urban areas like Tehran or Los Angeles simply blew the memory of even decently equipped systems.

    So whatever the system is, I think it needs to be optional, and it needs to work such that it deals with the worst-cases, urban sprawls to the horizon, and then take it from there.

    The current approach for random buildings and trees we use is more memory-friendly and is called instancing. There's a limited number of copies of objects which are all sitting at the origin, and their position and orientation information is passed in gl_Color to the vertex shader in every instance, and the building is then positioned inside the vertex shader. Like all shader-based techniques, this has the advantage that it can simply be turned off runtime, the density of buildings can dynamically be reduced by moving vertices out of the view frustrum early on by evaluating a threshold attribute against a random number, as evidenced by the forest effect, a limited amount of random patterns can be imposed after the fact altering e.g. size distribution of buildings slightly....

My secondary concern would then be with the high vertex density of roads - currently they're quite costly, and this hinges on a LOD system.

My third question would be how easy the techniqe can be extended by non-developers to different parts of the world, as cities in the US are rather different from cities in Europe .

As for the garden, if the information where to draw it can be represented in a 'simple' way, letting the shader draw the patches is not an issue. Representing the information efficiently may be the issue though. Basically the fragment shader has a position (xyz) and needs to call a function f(xyz) that returns 1 if a garden should be drawn (that's a bit like the cloud shadow problem). The function can be a texture, so a table lookup is performed, or something else (cloud shadows evaluate a series of distance checks to specified points)

A textured rectangle floating above the ground would be the easier solution, but it will float if the terrain is not level, so we need a solution which also works for sloped terrain. You could use a block instead, but then you get a terraced appearance of cities.

The best solution for high-end systems would probably be to pre-compute the building positions outside FG, from these assemble textures which contain the garden information at tile loading time and then use instancing to position the buildings inside the shader and the garden texture to determine vegetation as is done now at tile loading  time and use instancing to position the trees. I'm not completely clear on how to do this optionally though...

Hope that advances the discussion...

* Thorsten
---


2. die Straßen erstmal auch von osm2city als texturierte Bänder über die Scene legen. Kreuzungen etc kann man dann auch schön bemalen. Straßen in osm2city zu lesen brauche ich sowieso für mein Brücken-Projekt.

3. entlang der Straßen Häuser als shared models platzieren. Die shared models können jeweils einen texturierten “Garten” auf einer Grundfläche mitbringen. Diese Grundfläche passt osm2city an die tatsächliche elevation der scene an. Außerdem können die Häuser etwas mehr Details (ggf. mit LOD) besitzen, als lediglich die derzeitigen Fassaden.


The current approach of a generic urban texture + placement masks largely collides with 1.


1) is already possible with existing TG.

Source for building floorplans.
1. use some reasonable shared models placed procedurally along OSM roads.
  + can use somewhat detailed, hand-modeled buildings
  + can come with a patch of ground texture that perfectly matches the building
  - need a number of hand-modeled buildings

Texture for these shared models would be merged into an atlas. That's rather easy to script with python.

OR

2. use actual OSM data.
  - individual buildings won't be as detailled, but match real outline.

OR

3. mix both approaches: use OSM data for large buildings likely to be associated with the RL counterpart (until an individually modeled one becomes available), and place shared models for the boring ones, or if no OSM building coverage available.

I'm really in favour of 1. because of the level of detail possible.

Two general approaches: either outside of FG as a pre-processor (current state), or withing FG at terrain load time.

1. pre-processor
  - users get OSM data, generate city models outside of FG. This process can be highly automated (portreekid is working on this). Creating buildings is now reasonably quick, say some minutes for LOWI area.

2. integrate into FG.
  - need OSM line data


Shared model loading in FG:
- merge into one object/drawable.
As I understand, individual textures then have to be merged into one file. I could code a python script which:
    - for all .acs:
    -   load .ac
    -   if repeating textures found, reject .ac
    - for all accepted .acs:
    - create texture atlas
      - adapt texture coordinates
      - write .ac

Any plans to do this within FG? Should, in the light of reducing drawables, the use of repeating textures be discouraged?


Eine Weile lang war das auch mein Favorit, also der Ansatz “eine große Texture für eine Stadt”. Mein Besuch beim FSweekend und das Treffen mit den anderen FG-devs hat dann aber meine Pläne geändert. Ich bin nach wie vor begeistert, wieviel Performance das zusammenfassen von den Tausenden Objekten bringt. Ich kann locker 10km weit weg alle Häuser zeichnen und bekomme immer noch 20fps mit Intel HD 5000-Grafik. Demnächst ist vielleicht auch meine “große” Maschine wieder einsatzbereit mit richtiger Nvidia-Karte, bin mal gespannt, wie das dann rennt.

Ich plane daher nun eher in eine ähnliche Richtung wie X-Plane:

1. ein paar generische Texturen als Hintergrund

2. die Straßen erstmal auch von osm2city als texturierte Bänder über die Scene legen. Kreuzungen etc kann man dann auch schön bemalen. Straßen in osm2city zu lesen brauche ich sowieso für mein Brücken-Projekt.

3. entlang der Straßen Häuser als shared models platzieren. Die shared models können jeweils einen texturierten “Garten” auf einer Grundfläche mitbringen. Diese Grundfläche passt osm2city an die tatsächliche elevation der scene an. Außerdem können die Häuser etwas mehr Details (ggf. mit LOD) besitzen, als lediglich die derzeitigen Fassaden.

Die shared models kommen zunächst einzeln als .ac. Wenn man davon 20, 30, 100 Stück hat, sollte eine Stadt schon einigermaßen divers aussehen. ich würde mir mal anschauen, was in $FGDATA dazu schon rumliegt. osm2city liest das .ac, passt die Grundfläche an, und schreibt am Ende ein großes .ac per tile mit möglichst wenigen OBJECTs.

Shared models zu platzieren wäre auch eine Lösung für das Problem der teilweise schlechten OSM-Gebäudedichte. X-Plane platziert die Häuser nach einem offensichtlich recht simplen Algorithmus, und es sieht dennoch überzeugen genug aus.

4. große, markante OSM-Gebäude könnten nach wie vor als Fassade eingebaut werden.

Beide Ansätze schließen sich ja keinesfalls aus. Meine Nah-Ziele sind

- im aktuellen osm2city Fassaden/Dachtexturen zu fixen, und dann ein neues LOWI-release. Das sollte in den nächsten 2 Woche drin sein.
- dann die Straßen von OSM lesen, texturieren und schreiben, neues LOWI-release
- shared models lesen, anpassen, schreiben
- mal testweise Bäume als static objects entlang der Straßen pflanzen

Thomas
