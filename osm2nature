#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Script part of osm2city which takes OpenStreetMap data as input and generates data to be used in FlightGear
   * isolated trees

@author: rogue-spectre
"""

import argparse
import logging
import math
import os
import sys
import unittest
import xml.sax

import coordinates
import landuse
from landuse import Highway
import osmparser
import osmparser_wrapper
import parameters
import stg_io2
import tools
import vec2d
import re

from shapely.geometry import LineString
from shapely.geometry import MultiLineString
from shapely.geometry import Point
from shapely.geometry import Polygon

OUR_MAGIC = "osm2nature"  # Used in e.g. stg files to mark edits by osm2nature

class TreeNode(object):
    def __init__(self, osm_id):
        self.osm_id = osm_id
        self.switch = False
        self.buffer_stop = False
        self.lon = 0.0  # longitude coordinate in decimal as a float
        self.lat = 0.0  # latitude coordinate in decimal as a float
        self.x = 0.0  # local position x
        self.y = 0.0  # local position y
        self.elevation = 500.0  # elevation above sea level in meters
        #self.height = 5000.0 # height of the Tree
        #self.tree_model = "Models/Trees/buk3.xml"
        self.tree_model = "Models/Trees/platanus_acerifolia_15m.xml"
    def calc_global_coordinates(self, my_elev_interpolator, my_coord_transformator):
        self.lon, self.lat = my_coord_transformator.toGlobal((self.x, self.y))
        self.elevation = my_elev_interpolator(vec2d.vec2d(self.lon, self.lat), True)

    def calc_tree_model():
        pass

    def make_stg_entry(self, my_stg_mgr):
        """
        Returns a stg entry for this pylon.
        E.g. OBJECT_SHARED Models/Airport/ils.xml 5.313108 45.364122 374.49 268.92
        """
        #if not self.needs_stg_entry:
        #    return " "  # no need to write a shared object

        direction_correction = 0
        #if self.direction_type == SharedPylon.DIRECTION_TYPE_MIRROR:
        #    direction_correction = 180
        #elif self.direction_type == SharedPylon.DIRECTION_TYPE_END:
        #    direction_correction = 0
        #elif self.direction_type == SharedPylon.DIRECTION_TYPE_START:
        #    direction_correction = 180

        my_stg_mgr.add_object_shared(self.tree_model, vec2d.vec2d(self.lon, self.lat)
                                     , self.elevation
                                     , stg_angle(0))  # 90 less because arms are in x-direction in ac-file 
 
def process_osm_tree(nodes_dict, ways_dict, my_elev_interpolator, my_coord_transformator):
    my_trees = {}
    for node in nodes_dict.values():
        for key in node.tags :
            if node.tags[key] == "tree" :
                my_node = node
                my_tree_node = TreeNode(my_node.osm_id)
                my_tree_node.lat = my_node.lat
                my_tree_node.lon = my_node.lon
                # try to get a suitable model
                print(node.tags)
                try :
                    if "type" in node.tags :
                        if node.tags["type"] == "conifer" :
                            print("found conifer")
                            my_tree_node.tree_model = "Models/Trees/coniferous-tree.xml"
                        if node.tags["type"] == "palm" :
                            print("found palm")
                            my_tree_node.tree_model = "Models/Trees/palm02.xml"
                except :
                    self.tree_model="Models/Trees/platanus_acerifolia_15m.xml"

                self.tree_model="Models/Trees/egkk_woods.xml"

                my_tree_node.x, my_tree_node.y = my_coord_transformator.toLocal((my_tree_node.lon, my_tree_node.lat))
                my_tree_node.elevation =  my_elev_interpolator(vec2d.vec2d(my_tree_node.lon, my_tree_node.lat), True)
                print("adding entry to trees", my_node.osm_id, " ", my_tree_node.x, " ", my_tree_node.y, " ", my_tree_node.elevation)
                my_trees[my_tree_node.osm_id] = my_tree_node

    return my_trees

def process_osm_forest(nodes_dict, ways_dict, my_elev_interpolator, my_coord_transformator):
    """ fist stage put trees on contour """
    my_trees = {}
    for way in ways_dict.values():
        for key in way.tags :
            if way.tags[key] == "forest" :
                print("found forest")
                for ref in way.refs :
                    if ref in nodes_dict :
                        my_node = nodes_dict[ref]
                        my_tree_node = TreeNode(my_node.osm_id)
                        my_tree_node.lat = my_node.lat
                        my_tree_node.lon = my_node.lon
                        my_tree_node.x, my_tree_node.y = my_coord_transformator.toLocal((my_tree_node.lon, my_tree_node.lat))
                        my_tree_node.elevation =  my_elev_interpolator(vec2d.vec2d(my_tree_node.lon, my_tree_node.lat), True)
                        print("adding entry to trees", my_tree_node.x, my_tree_node.y, my_tree_node.elevation)
                        my_trees[my_tree_node.osm_id] = my_tree_node
    return my_trees


def write_stg_entries(my_stg_mgr, my_files_to_remove, lines_dict, wayname, cluster_max_length):
    line_index = 0
    for line in lines_dict.values():
        line_index += 1
        line.make_shared_pylons_stg_entries(my_stg_mgr)
        if None is not wayname:
            line.make_cables_ac_xml_stg_entries(my_stg_mgr, line_index, wayname, cluster_max_length, my_files_to_remove)


def stg_angle(angle_normal):
    """Returns the input angle in degrees to an angle for the stg-file in degrees.
    stg-files use angles counter-clockwise starting with 0 in North."""
    if 0 == angle_normal:
        return 0
    else:
        return 360 - angle_normal

def calc_distance(x1, y1, x2, y2):
    return math.sqrt(math.pow(x1 - x2, 2) + math.pow(y1 - y2, 2))

def main():
    # Handling arguments and parameters
    parser = argparse.ArgumentParser(
        description="osm2pylon reads OSM data and creates pylons, powerlines and aerialways for use with FlightGear")
    parser.add_argument("-f", "--file", dest="filename",
                        help="read parameters from FILE (e.g. params.ini)", metavar="FILE")
    parser.add_argument("-e", dest="e", action="store_true", help="skip elevation interpolation")
    parser.add_argument("-u", dest="uninstall", action="store_true", help="uninstall ours from .stg")
    parser.add_argument("-l", "--loglevel", help="set loglevel. Valid levels are VERBOSE, DEBUG, INFO, WARNING, ERROR, CRITICAL")
    args = parser.parse_args()
    if args.filename is not None:
        parameters.read_from_file(args.filename)
    parameters.set_loglevel(args.loglevel)  # -- must go after reading params file
    if args.e:
        parameters.NO_ELEV = True
    files_to_remove = None
    if args.uninstall:
        logging.info("Uninstalling.")
        files_to_remove = []
        parameters.NO_ELEV = True

    # Initializing tools for global/local coordinate transformations
    center_global = parameters.get_center_global()
    osm_fname = parameters.get_OSM_file_name()
    coord_transformator = coordinates.Transformation(center_global, hdg=0)
    tools.init(coord_transformator)

    # Reading elevation data
    logging.info("Reading ground elevation data might take some time ...")
    elev_interpolator = tools.get_interpolator(fake=parameters.NO_ELEV)

    # Transform to real objects
    logging.info("Transforming OSM data to Line and Pylon objects")
    # the lists below are in sequence: buildings references, power/aerialway, railway overhead, landuse and highway
    valid_node_keys = ["natural","landuse","type"]
    #valid_node_keys = ["power", "structure", "material", "height", "colour", "aerialway"
    #                   , "railway"]
    #valid_way_keys = ["building"
    #                  , "power", "aerialway", "voltage", "cables", "wires"
    #                  , "railway", "electrified", "tunnel"
    #                  , "landuse"
    #                  , "highway", "junction"]
    valid_way_keys = ["landuse"]
    valid_relation_keys = []
    req_relation_keys = []
    #req_way_keys = ["building", "power", "aerialway", "railway", "landuse", "highway"]
    req_way_keys = ["natural","landuse"]
    handler = osmparser_wrapper.OSMContentHandler(valid_node_keys, valid_way_keys, req_way_keys, valid_relation_keys,
                                                  req_relation_keys)
    source = open(osm_fname)
    xml.sax.parse(source, handler)
    # References for buildings
    trees = {}
    forest_trees = {}
    if True :#parameters.PROCESS_TREES :
        trees = process_osm_tree(handler.nodes_dict, handler.ways_dict, elev_interpolator
                                                             , coord_transformator)
        logging.info('Number of trees to process: %s', len(trees))
    #if True :
    #    forest_trees = process_osm_forest(handler.nodes_dict, handler.ways_dict, elev_interpolator
    #                                                         , coord_transformator)
    #    logging.info('Number of forest to process: %s', len(trees))
    #    # -- initialize STG_Manager
    if parameters.PATH_TO_OUTPUT:
        path_to_output = parameters.PATH_TO_OUTPUT
    else:
        path_to_output = parameters.PATH_TO_SCENERY
    replacement_prefix = re.sub('[\/]', '_', parameters.PREFIX)
    stg_manager = stg_io2.STG_Manager(path_to_output, OUR_MAGIC, replacement_prefix, overwrite=True)

    #write_stg_entries(stg_manager, files_to_remove, trees, "trees", 2000)
    for tree in trees.values() :
        print(tree.elevation)
        tree.make_stg_entry(stg_manager)
        #write_stg_entries(stg_manager, files_to_remove, trees, "trees", 2000)
    for forest_tree in forest_trees.values() :
        print(forest_tree.elevation)
        forest_tree.make_stg_entry(stg_manager)

    # free some memory
    building_refs = None
    handler = None

    # -- initialize STG_Manager
    if args.uninstall:
        for f in files_to_remove:
            try:
                os.remove(f)
            except IOError:
                pass
        stg_manager.drop_ours()
        stg_manager.write()
        logging.info("uninstall done.")
        sys.exit(0)

    stg_manager.write()
    elev_interpolator.save_cache()

    logging.info("******* Finished *******")


if __name__ == "__main__":
    main()


# ================ UNITTESTS =======================


class TestOSMPylons(unittest.TestCase):
    def test_angle_of_line(self):
        self.assertEqual(0, calc_angle_of_line(0, 0, 0, 1), "North")
        self.assertEqual(90, calc_angle_of_line(0, 0, 1, 0), "East")
        self.assertEqual(180, calc_angle_of_line(0, 1, 0, 0), "South")
        self.assertEqual(270, calc_angle_of_line(1, 0, 0, 0), "West")
        self.assertEqual(45, calc_angle_of_line(0, 0, 1, 1), "North East")
        self.assertEqual(315, calc_angle_of_line(1, 0, 0, 1), "North West")
        self.assertEqual(225, calc_angle_of_line(1, 1, 0, 0), "South West")

    def test_middle_angle(self):
        self.assertEqual(0, calc_middle_angle(0, 0), "North North")
        self.assertEqual(45, calc_middle_angle(0, 90), "North East")
        self.assertEqual(130, calc_middle_angle(90, 170), "East Almost_South")
        self.assertEqual(90, calc_middle_angle(135, 45), "South_East North_East")
        self.assertEqual(0, calc_middle_angle(45, 315), "South_East North_East")
        self.assertEqual(260, calc_middle_angle(170, 350), "Almost_South Almost_North")

    def test_distance(self):
        self.assertEqual(5, calc_distance(0, -1, -4, 2))

    def test_wayline_calculate_and_map(self):
        # first test headings
        pylon1 = Pylon(1)
        pylon1.x = -100
        pylon1.y = -100
        pylon2 = Pylon(2)
        pylon2.x = 100
        pylon2.y = 100
        wayline1 = WayLine(100)
        wayline1.type_ = WayLine.TYPE_POWER_LINE
        wayline1.shared_pylons.append(pylon1)
        wayline1.shared_pylons.append(pylon2)
        wayline1.calc_and_map()
        self.assertAlmostEqual(45, pylon1.heading, 2)
        self.assertAlmostEqual(45, pylon2.heading, 2)
        pylon3 = Pylon(3)
        pylon3.x = 0
        pylon3.y = 100
        pylon4 = Pylon(4)
        pylon4.x = -100
        pylon4.y = 200
        wayline1.shared_pylons.append(pylon3)
        wayline1.shared_pylons.append(pylon4)
        wayline1.calc_and_map()
        self.assertAlmostEqual(337.5, pylon2.heading, 2)
        self.assertAlmostEqual(292.5, pylon3.heading, 2)
        self.assertAlmostEqual(315, pylon4.heading, 2)
        pylon5 = Pylon(5)
        pylon5.x = -100
        pylon5.y = 300
        wayline1.shared_pylons.append(pylon5)
        wayline1.calc_and_map()
        self.assertAlmostEqual(337.5, pylon4.heading, 2)
        self.assertAlmostEqual(0, pylon5.heading, 2)
        # then test other stuff
        self.assertEqual(4, len(wayline1.way_segments))

    def test_cable_vertex_calc_position(self):
        vertex = CableVertex(10, 5)
        vertex.calc_position(0, 0, 20, 0)
        self.assertAlmostEqual(25, vertex.elevation, 2)
        self.assertAlmostEqual(10, vertex.x, 2)
        self.assertAlmostEqual(0, vertex.y, 2)
        vertex.calc_position(0, 0, 20, 90)
        self.assertAlmostEqual(0, vertex.x, 2)
        self.assertAlmostEqual(-10, vertex.y, 2)
        vertex.calc_position(0, 0, 20, 210)
        self.assertAlmostEqual(-8.660, vertex.x, 2)
        self.assertAlmostEqual(5, vertex.y, 2)
        vertex.calc_position(20, 50, 20, 180)
        self.assertAlmostEqual(10, vertex.x, 2)
        self.assertAlmostEqual(50, vertex.y, 2)

    def test_catenary(self):
        #  Values taken form example 2 in http://www.mathdemos.org/mathdemos/catenary/catenary.html
        a, value = optimize_catenary(170, 5000, 14, 0.01)
        print a, value
        self.assertAlmostEqual(1034/100, a/100, 2)

    def test_merge_lines(self):
        line_u = RailLine("u")
        line_v = RailLine("v")
        line_w = RailLine("w")
        line_x = RailLine("x")
        line_y = RailLine("y")
        node1 = RailNode("1")
        node2 = RailNode("2")
        node3 = RailNode("3")
        node4 = RailNode("4")
        node5 = RailNode("5")
        node6 = RailNode("6")
        node7 = RailNode("7")
        shared_nodes = {}

        line_u.nodes.append(node1)
        line_u.nodes.append(node2)
        line_v.nodes.append(node2)
        line_v.nodes.append(node3)
        merge_lines("2", line_u, line_v, shared_nodes)
        self.assertEqual(3, len(line_u.nodes))
        line_w.nodes.append(node1)
        line_w.nodes.append(node4)
        merge_lines("1", line_u, line_w, shared_nodes)
        self.assertEqual(4, len(line_u.nodes))
        line_x.nodes.append(node5)
        line_x.nodes.append(node3)
        merge_lines("3", line_u, line_x, shared_nodes)
        self.assertEqual(5, len(line_u.nodes))
        line_y.nodes.append(node7)
        line_y.nodes.append(node6)
        line_y.nodes.append(node4)
        merge_lines("4", line_u, line_y, shared_nodes)
        self.assertEqual(7, len(line_u.nodes))

    def find_connecting_line(self):
        node1 = RailNode("1")
        node1.x = 5
        node1.y = 10
        node2 = RailNode("2")
        node2.x = 10
        node2.y = 10
        node3 = RailNode("3")
        node3.x = 20
        node3.y = 5
        node4 = RailNode("4")
        node4.x = 20
        node4.y = 20

        line_u = RailLine("u")
        line_u.nodes.append(node1)
        line_u.nodes.append(node2)
        line_v = RailLine("v")
        line_v.nodes.append(node2)
        line_v.nodes.append(node3)
        line_w = RailLine("w")
        line_w.nodes.append(node4)
        line_w.nodes.append(node2)

        lines = [line_u, line_v, line_w]
        pos1, pos2 = find_connecting_line("2", lines)
        self.assertEqual(0, pos1)
        self.assertEqual(1, pos2)
